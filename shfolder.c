/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall zzOpenCurrentModuleAndWalkThroughIt(__int64 a1);
__int64 __fastcall zzMyCryptImportKey(HCRYPTPROV hProv, BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey);
__int64 __fastcall zzFindAndModImportCryptKey(__int64 a1);
HRESULT __stdcall SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
void **zzGetFree38hBuf();
int __fastcall zzLoopThreadsAndModifyContext(struct struct_tid_list *a1, unsigned int a2, int hookOrNot); // idb
BOOL __fastcall zzResumeAllThreadAndFreeList(struct struct_tid_list *tid_list);
signed __int64 __fastcall zzProtectInstrAnd(unsigned int arg1_idx, int a2); // idb
__int64 __fastcall zzHookAllThread(unsigned int hookOrNot); // idb
__int64 __fastcall mutex_lock_g_lock_1();
__int64 zzDoCleanUp();
__int64 __fastcall zzHookLibFunc(void *origFuncAddr);
signed __int64 __fastcall zzCheckInjectSpaceAvail(_BYTE *p, unsigned int len); // idb
signed __int64 __fastcall CreateTrampolineFunction(void *orig_func_addr);
_QWORD *__fastcall zzAllocFuncPage(unsigned __int64 a1);
int __fastcall zzPageNeedFree(unsigned __int64 *a1);
BOOL __fastcall zzIsAddrPermOk(void *);
__int64 __fastcall hde64_disasm(unsigned __int8 *code, unsigned __int8 *hs); // idb
// __int64 __fastcall _C_specific_handler(PEXCEPTION_RECORD ExceptionRecord, PVOID TargetFrame, __int64 a3, _QWORD *a4);
void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
void __fastcall zzRtlUnwindEx(void *a1, void *a2);
void zzEmptyFunc();
__int64 nullsub_1(void); // weak
__int64 __fastcall nullsub_2(_QWORD); // weak
// void __stdcall RtlUnwindEx(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable);
signed __int64 __fastcall zzFindSectionForAddr(void *p_img, unsigned __int64 addr);
char __fastcall zzInSectionNeedRelocation(__int64 p_instr);
bool __fastcall zzValidatePE64Image(void *p);
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// HANDLE __stdcall CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
// LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
// BOOL __stdcall Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall SuspendThread(HANDLE hThread);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// void __stdcall Sleep(DWORD dwMilliseconds);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
// BOOL __stdcall GetThreadContext(HANDLE hThread, LPCONTEXT lpContext);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// DWORD __stdcall GetCurrentProcessId();
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// BOOL __stdcall FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize);
// BOOL __stdcall SetThreadContext(HANDLE hThread, const CONTEXT *lpContext);
// HANDLE __stdcall OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// void __stdcall RtlUnwindEx(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable);
// HRESULT __stdcall SHGetFolderPathA_0(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);

//-------------------------------------------------------------------------
// Data declarations

_DWORD dword_403190[256] =
{
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918000,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
}; // idb
char rsa1_cert_1 = '\x06'; // weak
_UNKNOWN rsa1_cert_2; // weak
_UNKNOWN unk_405010; // weak
_UNKNOWN unk_40505A; // weak
_UNKNOWN unk_4051BE; // weak
_UNKNOWN unk_4051D6; // weak
_UNKNOWN unk_4051E8; // weak
_UNKNOWN unk_4051F7; // weak
_UNKNOWN unk_405221; // weak
const WCHAR ModuleFileName; // idb
__int64 (__fastcall *handler_list_last_node)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
int g_lock_1; // weak
HANDLE hHeap; // idb
LPVOID lpAddress; // idb
void **g_pp_buf;
int zz_g_buf_38h_cnt; // weak
int zz_g_buf_38h_used_cnt; // weak


//----- (0000000000401000) ----------------------------------------------------
__int64 __fastcall zzOpenCurrentModuleAndWalkThroughIt(__int64 a1)
{
    unsigned int v1; // edi
    HANDLE v2; // rax
    void *v3; // rsi
    unsigned int v4; // ebx
    DWORD v5; // ebp
    HANDLE v6; // rax
    void *v7; // r14
    char *v8; // rax
    __int64 v9; // r8
    char *v10; // r9
    char v11; // cl
    __int64 FileSizeHigh; // [rsp+60h] [rbp+8h]

    FileSizeHigh = a1;
    v1 = 0;
    v2 = CreateFileW(&ModuleFileName, 0x80000000, 1u, 0i64, 3u, 0x80u, 0i64);
    v3 = v2;
    if ( v2 != (HANDLE)0xFFFFFFFFFFFFFFFFi64 )
    {
        LODWORD(FileSizeHigh) = 0;
        v4 = 0xFFFFFFFF;
        v5 = GetFileSize(v2, (LPDWORD)&FileSizeHigh);
        if ( v5 != 0xFFFFFFFF && !(_DWORD)FileSizeHigh )
        {
            v6 = CreateFileMappingW(v3, 0i64, 2u, 0, 0, 0i64);
            v7 = v6;
            if ( v6 != (HANDLE)0xFFFFFFFFFFFFFFFFi64 )
            {
                v8 = (char *)MapViewOfFile(v6, 4u, 0, 0, 0i64);
                if ( v8 )
                {
                    v9 = v5;
                    v10 = v8;
                    if ( v5 )
                    {
                        do
                        {
                            v11 = *v10++;
                            v4 = (v4 >> 8) ^ dword_403190[(unsigned __int8)(v4 ^ v11)];
                            --v9;
                        }
                        while ( v9 );
                    }
                    v1 = ~v4;
                    UnmapViewOfFile(v8);
                }
                CloseHandle(v7);
            }
        }
        CloseHandle(v3);
    }
    return v1;
}

//----- (0000000000401140) ----------------------------------------------------
__int64 __fastcall zzMyCryptImportKey(HCRYPTPROV hProv, BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey)
{
    HCRYPTKEY v6; // rsi
    DWORD v7; // edi
    BYTE *v8; // rbx
    HCRYPTPROV v9; // r14

    v6 = hPubKey;
    v7 = dwDataLen;
    v8 = pbData;
    v9 = hProv;
    if ( pbData && dwDataLen == 0x114 && !(unsigned int)memcpy(pbData, &rsa1_cert_2, 0x114ui64) )
        v8 = (BYTE *)&rsa1_cert_1;
    return handler_list_last_node(v9, v8, v7, v6, dwFlags, phKey);
}
// 405BB0: invalid function type has been ignored
// 403590: using guessed type char rsa1_cert_1;
// 405BB0: using guessed type __int64 (__fastcall *handler_list_last_node)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000004011F0) ----------------------------------------------------
__int64 __fastcall zzFindAndModImportCryptKey(__int64 a1)
{
    signed int v1; // esi
    unsigned __int64 i; // rbx
    __int64 result; // rax
    unsigned __int64 v4; // rbx

    v1 = 0;
    for ( i = 0i64; _InterlockedCompareExchange(&g_lock_1, 1, 0); ++i )
        Sleep(i >= 0x20);
    if ( hHeap )
    {
        v1 = 1;
    }
    else
    {
        hHeap = HeapCreate(0, 0i64, 0i64);
        if ( !hHeap )
            v1 = 9;
    }
    result = (unsigned int)_InterlockedExchange(&g_lock_1, 0);
    if ( !v1 )
    {
        result = zzOpenCurrentModuleAndWalkThroughIt(a1);
        if ( !(_DWORD)result )
        {
            result = (__int64)GetModuleHandleW(L"advapi32.dll");
            if ( result )
            {
                result = (__int64)GetProcAddress((HMODULE)result, "CryptImportKey");
                if ( result )
                {
                    result = zzHookLibFunc((void *)result);
                    if ( !(_DWORD)result )
                    {
                        v4 = 0i64;
                        for ( result = (unsigned int)_InterlockedCompareExchange(&g_lock_1, 1, 0);
                              (_DWORD)result;
                              result = (unsigned int)_InterlockedCompareExchange(&g_lock_1, 1, 0) )
                        {
                            Sleep(v4++ >= 0x20);
                        }
                        if ( hHeap )
                            result = zzHookAllThread(1u);
                        _InterlockedExchange(&g_lock_1, 0);
                    }
                }
            }
        }
    }
    return result;
}
// 405BB8: using guessed type int g_lock_1;

//----- (0000000000401310) ----------------------------------------------------
HRESULT __stdcall SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath)
{
    return SHGetFolderPathA_0(hwnd, csidl, 0i64, 0, pszPath);
}

//----- (0000000000401330) ----------------------------------------------------
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
    HINSTANCE hModule; // rbx
    __int64 v4; // rcx
    BOOL result; // eax
    unsigned __int64 i; // rdi

    hModule = hinstDLL;
    if ( fdwReason )
    {
        if ( fdwReason == 1 )
        {
            DisableThreadLibraryCalls(hinstDLL);
            GetModuleFileNameW(hModule, (LPWSTR)&ModuleFileName, 0x208u);
            zzFindAndModImportCryptKey(v4);
        }
        result = 1;
    }
    else
    {
        for ( i = 0i64; _InterlockedCompareExchange(&g_lock_1, 1, 0); ++i )
            Sleep(i >= 0x20);
        if ( hHeap )
            zzHookAllThread(0);
        _InterlockedExchange(&g_lock_1, 0);
        zzDoCleanUp();
        result = 1;
    }
    return result;
}
// 405BB8: using guessed type int g_lock_1;

//----- (00000000004013E0) ----------------------------------------------------
void **zzGetFree38hBuf()
{
    void **buf; // rdx
    void **result; // rax
    unsigned int used_cnt; // ecx

    buf = g_pp_buf;
    if ( !g_pp_buf )
    {
        zz_g_buf_38h_cnt = 0x20;
        g_pp_buf = (void **)HeapAlloc(hHeap, (DWORD)g_pp_buf, 0x700ui64);
        buf = g_pp_buf;
        if ( !g_pp_buf )
            return 0i64;
        goto alloc_ok;
    }
    used_cnt = zz_g_buf_38h_used_cnt;
    if ( zz_g_buf_38h_used_cnt >= (unsigned int)zz_g_buf_38h_cnt )
    {
        buf = (void **)HeapReAlloc(hHeap, 0, g_pp_buf, 0x38i64 * (unsigned int)(2 * zz_g_buf_38h_cnt));
        if ( !buf )
            return 0i64;
        g_pp_buf = buf;
        zz_g_buf_38h_cnt *= 2;
alloc_ok:
        used_cnt = zz_g_buf_38h_used_cnt;
    }
    result = &buf[7 * used_cnt];
    zz_g_buf_38h_used_cnt = used_cnt + 1;
    return result;
}
// 405BE8: using guessed type int zz_g_buf_38h_cnt;
// 405BEC: using guessed type int zz_g_buf_38h_used_cnt;

//----- (0000000000401484) ----------------------------------------------------
int __fastcall zzLoopThreadsAndModifyContext(struct struct_tid_list *a1, unsigned int a2, int hookOrNot)
{
    unsigned int buf_idx; // er13
    struct struct_tid_list *tid_list; // rbx
    HANDLE hThread; // rax
    void *v6; // rdi
    BOOL i; // eax
    HANDLE v8; // rcx
    LPVOID v9; // rax
    unsigned int v10; // eax
    LPVOID v11; // rax
    int v12; // ecx
    unsigned int tid_idx; // esi
    int v14; // edi
    void *hThread_1; // r14
    unsigned int used_cnt; // ecx
    unsigned int idx; // edx
    DWORD64 vRIP; // r10
    signed __int64 v19; // r15
    __int64 left_cnt; // r12
    void **v21; // rdx
    unsigned int v22; // er8
    __int64 v23; // r9
    unsigned int v24; // er8
    DWORD64 v25; // rcx
    __int64 v26; // r9
    unsigned int v27; // er8
    int v29; // [rsp+20h] [rbp-E0h]
    struct struct_tid_list *v30; // [rsp+28h] [rbp-D8h]
    THREADENTRY32 te; // [rsp+30h] [rbp-D0h]
    struct _CONTEXT Context; // [rsp+50h] [rbp-B0h]

    buf_idx = a2;
    v30 = a1;
    v29 = hookOrNot;
    tid_list = a1;
    a1->pbuf = 0i64;
    *(_QWORD *)&a1->max_cnt = 0i64;
    hThread = CreateToolhelp32Snapshot(4u, 0);
    v6 = hThread;
    if ( hThread != (HANDLE)0xFFFFFFFFFFFFFFFFi64 )
    {
        te.dwSize = 0x1C;
        for ( i = Thread32First(hThread, &te); i; i = Thread32Next(v6, &te) )
        {
            if ( te.dwSize >= 0x10
              && te.th32OwnerProcessID == GetCurrentProcessId()
              && te.th32ThreadID != GetCurrentThreadId() )
            {
                if ( tid_list->pbuf )
                {
                    v10 = tid_list->max_cnt;
                    if ( tid_list->used_cnt >= v10 )
                    {
                        v11 = HeapReAlloc(hHeap, 0, (LPVOID)tid_list->pbuf, 8i64 * v10);
                        if ( !v11 )
                            break;
                        v12 = tid_list->max_cnt;
                        tid_list->pbuf = (__int64)v11;
                        tid_list->max_cnt = 2 * v12;
                    }
                }
                else
                {
                    v8 = hHeap;
                    tid_list->max_cnt = 0x80;
                    v9 = HeapAlloc(v8, 0, 0x200ui64);
                    tid_list->pbuf = (__int64)v9;
                    if ( !v9 )
                        break;
                }
                *(_DWORD *)(tid_list->pbuf + 4i64 * (unsigned int)tid_list->used_cnt++) = te.th32ThreadID;
            }
            te.dwSize = 0x1C;
        }
        LODWORD(hThread) = CloseHandle(v6);
    }
    if ( tid_list->pbuf )
    {
        tid_idx = 0;
        if ( tid_list->used_cnt > 0u )
        {
            v14 = v29;
            do
            {
                hThread = OpenThread(0x5Au, 0, *(_DWORD *)(tid_list->pbuf + 4i64 * tid_idx));
                hThread_1 = hThread;
                if ( hThread )
                {
                    SuspendThread(hThread);
                    Context.ContextFlags = 0x100001;
                    if ( GetThreadContext(hThread_1, &Context) )
                    {
                        used_cnt = zz_g_buf_38h_used_cnt;
                        if ( buf_idx != 0xFFFFFFFF )
                            used_cnt = buf_idx + 1;
                        idx = 0;
                        if ( buf_idx != 0xFFFFFFFF )
                            idx = buf_idx;
                        if ( idx < used_cnt )
                        {
                            vRIP = Context.Rip;
                            v19 = 7i64 * idx;
                            left_cnt = used_cnt - idx;
                            while ( 2 )
                            {
                                v21 = &g_pp_buf[v19];
                                if ( v29 )
                                {
                                    if ( v29 == 1 )
                                    {
                                        v14 = 1;
                                    }
                                    else if ( v29 == 2 )
                                    {
                                        v14 = -__CFSHR__(*((_DWORD *)v21 + 8), 3);
                                    }
                                }
                                else
                                {
                                    v14 = 0;
                                }
                                v22 = *((_DWORD *)v21 + 8);
                                if ( -__CFSHR__(*((_DWORD *)v21 + 8), 2) == v14 )
                                    goto LABEL_41;
                                if ( v14 )
                                {
                                    v23 = 0i64;
                                    v24 = (v22 >> 3) & 0xF;
                                    if ( v24 )
                                    {
                                        while ( (void *)vRIP != (char *)*v21 + *((unsigned __int8 *)v21 + v23 + 0x24) )
                                        {
                                            v23 = (unsigned int)(v23 + 1);
                                            if ( (unsigned int)v23 >= v24 )
                                                goto LABEL_38;
                                        }
                                        v25 = (DWORD64)v21[2] + *((unsigned __int8 *)v21 + v23 + 0x2C);
                                        goto LABEL_39;
                                    }
                                }
                                else
                                {
                                    if ( v22 & 1 )
                                    {
                                        v25 = (DWORD64)*v21;
                                        if ( (_BYTE *)vRIP == (char *)*v21 + 0xFFFFFFFB )
                                            goto LABEL_39;
                                    }
                                    v26 = 0i64;
                                    v27 = (v22 >> 3) & 0xF;
                                    if ( v27 )
                                    {
                                        while ( (void *)vRIP != (char *)v21[2] + *((unsigned __int8 *)v21 + v26 + 0x2C) )
                                        {
                                            v26 = (unsigned int)(v26 + 1);
                                            if ( (unsigned int)v26 >= v27 )
                                                goto LABEL_52;
                                        }
                                        v25 = (DWORD64)*v21 + *((unsigned __int8 *)v21 + v26 + 0x24);
LABEL_39:
                                        if ( v25 )
                                        {
                                            Context.Rip = v25;
                                            SetThreadContext(hThread_1, &Context);
                                            vRIP = Context.Rip;
                                        }
LABEL_41:
                                        v19 += 7i64;
                                        if ( !--left_cnt )
                                        {
                                            tid_list = v30;
                                            goto get_thread_context_fail;
                                        }
                                        continue;
                                    }
LABEL_52:
                                    if ( (void *)vRIP == v21[1] )
                                    {
                                        v25 = (DWORD64)*v21;
                                        goto LABEL_39;
                                    }
                                }
                                break;
                            }
LABEL_38:
                            v25 = 0i64;
                            goto LABEL_39;
                        }
                    }
get_thread_context_fail:
                    LODWORD(hThread) = CloseHandle(hThread_1);
                }
                ++tid_idx;
            }
            while ( tid_idx < tid_list->used_cnt );
        }
    }
    return (signed int)hThread;
}
// 405BEC: using guessed type int zz_g_buf_38h_used_cnt;

//----- (000000000040179C) ----------------------------------------------------
BOOL __fastcall zzResumeAllThreadAndFreeList(struct struct_tid_list *tid_list)
{
    __int64 idx; // rbx
    struct struct_tid_list *tid_list_1; // rdi
    HANDLE hThread; // rax
    void *hThread_1; // rsi

    idx = 0i64;
    tid_list_1 = tid_list;
    if ( tid_list->used_cnt )
    {
        do
        {
            hThread = OpenThread(0x5Au, 0, *(_DWORD *)(tid_list_1->pbuf + 4 * idx));
            hThread_1 = hThread;
            if ( hThread )
            {
                ResumeThread(hThread);
                CloseHandle(hThread_1);
            }
            idx = (unsigned int)(idx + 1);
        }
        while ( (unsigned int)idx < tid_list_1->used_cnt );
    }
    return HeapFree(hHeap, 0, (LPVOID)tid_list_1->pbuf);
}

//----- (000000000040180C) ----------------------------------------------------
signed __int64 __fastcall zzProtectInstrAnd(unsigned int arg1_idx, int a2)
{
    int v2; // er14
    SIZE_T v3; // rsi
    void **v4; // rbx
    _BYTE *v5; // rdi
    bool v7; // zf
    HANDLE v8; // rax
    DWORD flOldProtect; // [rsp+30h] [rbp+8h]

    v2 = a2;
    v3 = 5i64;
    v4 = &g_pp_buf[7 * arg1_idx];
    v5 = *v4;
    if ( (_BYTE)v4[4] & 1 )
    {
        v5 += 0xFFFFFFFB;
        v3 = 7i64;
    }
    if ( !VirtualProtect(v5, v3, 0x40u, &flOldProtect) )
        return 0xAi64;
    if ( v2 )
    {
        *v5 = 0xE9u;
        *(_DWORD *)(v5 + 1) = *((_DWORD *)v4 + 2) - (_DWORD)v5 - 5;
        if ( (_BYTE)v4[4] & 1 )
            *(_WORD *)*v4 = 0xF9EBu;
    }
    else
    {
        v7 = ((_BYTE)v4[4] & 1) == 0;
        *(_DWORD *)v5 = *((_DWORD *)v4 + 6);
        if ( v7 )
        {
            v5[4] = *((_BYTE *)v4 + 0x1C);
        }
        else
        {
            *((_WORD *)v5 + 2) = *((_WORD *)v4 + 0xE);
            v5[6] = *((_BYTE *)v4 + 0x1E);
        }
    }
    VirtualProtect(v5, v3, flOldProtect, &flOldProtect);
    v8 = GetCurrentProcess();
    FlushInstructionCache(v8, v5, v3);
    *((_DWORD *)v4 + 8) &= 0xFFFFFFF9;
    *((_DWORD *)v4 + 8) |= 2 * (2 * (v2 & 1) | v2 & 1);
    return 0i64;
}

//----- (000000000040190C) ----------------------------------------------------
__int64 __fastcall zzHookAllThread(unsigned int hookOrNot)
{
    int vhookOrNot; // esi
    unsigned int ret; // edi
    unsigned int idx; // ebx
    void **v4; // rdx
    unsigned int cnt; // er8
    struct struct_tid_list tid_list; // [rsp+20h] [rbp-18h]

    vhookOrNot = hookOrNot;
    ret = 0;
    idx = 0;
    if ( zz_g_buf_38h_used_cnt )
    {
        v4 = g_pp_buf + 4;
        while ( -__CFSHR__(*(_DWORD *)v4, 2) == hookOrNot )
        {
            ++idx;
            v4 += 7;
            if ( idx >= zz_g_buf_38h_used_cnt )
                return ret;
        }
        if ( idx != 0xFFFFFFFF )
        {
            zzLoopThreadsAndModifyContext(&tid_list, 0xFFFFFFFF, hookOrNot != 0);
            cnt = zz_g_buf_38h_used_cnt;
            while ( idx < cnt )
            {
                if ( -__CFSHR__(g_pp_buf[7 * idx + 4], 2) != vhookOrNot )
                {
                    ret = zzProtectInstrAnd(idx, vhookOrNot);
                    if ( ret )
                        break;
                    cnt = zz_g_buf_38h_used_cnt;
                }
                ++idx;
            }
            if ( tid_list.pbuf )
                zzResumeAllThreadAndFreeList(&tid_list);
        }
    }
    return ret;
}
// 405BEC: using guessed type int zz_g_buf_38h_used_cnt;

//----- (00000000004019D0) ----------------------------------------------------
__int64 __fastcall mutex_lock_g_lock_1()
{
    unsigned __int64 i; // rbx
    __int64 result; // rax

    for ( i = 0i64; ; ++i )
    {
        result = (unsigned int)_InterlockedCompareExchange(&g_lock_1, 1, 0);
        if ( !(_DWORD)result )
            break;
        Sleep(i >= 0x20);
    }
    return result;
}
// 405BB8: using guessed type int g_lock_1;

//----- (0000000000401A10) ----------------------------------------------------
__int64 zzDoCleanUp()
{
    unsigned int v0; // esi
    _QWORD *v1; // rcx
    _QWORD *v2; // rbx

    mutex_lock_g_lock_1();
    if ( hHeap )
    {
        v0 = zzHookAllThread(0);
        if ( !v0 )
        {
            v1 = lpAddress;
            lpAddress = 0i64;
            if ( v1 )
            {
                do
                {
                    v2 = (_QWORD *)*v1;
                    VirtualFree(v1, 0i64, 0x8000u);
                    v1 = v2;
                }
                while ( v2 );
            }
            HeapFree(hHeap, 0, g_pp_buf);
            HeapDestroy(hHeap);
            hHeap = 0i64;
            g_pp_buf = 0i64;
            *(_QWORD *)&zz_g_buf_38h_cnt = 0i64;
        }
    }
    else
    {
        v0 = 2;
    }
    _InterlockedExchange(&g_lock_1, 0);
    return v0;
}
// 405BB8: using guessed type int g_lock_1;
// 405BE8: using guessed type int zz_g_buf_38h_cnt;

//----- (0000000000401AC0) ----------------------------------------------------
__int64 __fastcall zzHookLibFunc(void *origFuncAddr)
{
    unsigned __int64 *orig_func_addr; // rsi
    unsigned int v2; // ebx
    unsigned int v3; // eax
    void **p1; // rcx
    _QWORD *v5; // rax
    unsigned __int64 *v6; // r14
    unsigned __int64 v7; // rcx
    void **v8; // rax
    void **v9; // rdx
    unsigned __int64 *v10; // r8
    char v11; // cl
    __int64 v12; // rax
    void *orig_func_addr_1; // [rsp+20h] [rbp-58h]
    __int64 (__fastcall *v15)(HCRYPTPROV, BYTE *, DWORD, HCRYPTKEY, DWORD, HCRYPTKEY *); // [rsp+28h] [rbp-50h]
    unsigned __int64 *v16; // [rsp+30h] [rbp-48h]
    void *v17; // [rsp+38h] [rbp-40h]
    int v18; // [rsp+40h] [rbp-38h]
    int v19; // [rsp+44h] [rbp-34h]
    __int64 v20; // [rsp+48h] [rbp-30h]
    void *v21; // [rsp+50h] [rbp-28h]

    orig_func_addr = (unsigned __int64 *)origFuncAddr;
    v2 = 0;
    mutex_lock_g_lock_1();
    if ( !hHeap )
    {
        v2 = 2;
        goto done;
    }
    if ( !zzIsAddrPermOk(orig_func_addr) || !zzIsAddrPermOk(zzMyCryptImportKey) )
    {
        v2 = 7;
        goto done;
    }
    v3 = 0;
    if ( zz_g_buf_38h_used_cnt )
    {
        p1 = g_pp_buf;
        while ( orig_func_addr != *p1 )
        {
            ++v3;
            p1 += 7;
            if ( v3 >= zz_g_buf_38h_used_cnt )
                goto no_thread_executing_CryptImportKey;
        }
    }
    else
    {
no_thread_executing_CryptImportKey:
        v3 = 0xFFFFFFFF;
    }
    if ( v3 != 0xFFFFFFFF )
    {
        v2 = 3;
        goto done;
    }
    v5 = zzAllocFuncPage((unsigned __int64)orig_func_addr);
    if ( !v5 )
    {
        v2 = 9;
        goto done;
    }
    v6 = (unsigned __int64 *)v5[1];
    orig_func_addr_1 = orig_func_addr;
    v15 = zzMyCryptImportKey;
    v16 = v6;
    v7 = *v6;
    ++*((_DWORD *)v5 + 4);
    v5[1] = v7;
    if ( !(unsigned int)CreateTrampolineFunction(&orig_func_addr_1) )
    {
        v2 = 8;
        goto LABEL_19;
    }
    v8 = zzGetFree38hBuf();
    v9 = v8;
    if ( !v8 )
    {
        v2 = 9;
LABEL_19:
        zzPageNeedFree(v6);
        goto done;
    }
    *((_DWORD *)v8 + 8) &= 0xFFFFFF80;
    v10 = v16;
    *v8 = orig_func_addr_1;
    v8[1] = v17;
    v11 = v19;
    v8[2] = v10;
    v12 = v20;
    *((_DWORD *)v9 + 8) |= v18 & 1 | 8 * (v11 & 0xF);
    *(void **)((char *)v9 + 0x24) = (void *)v12;
    *(void **)((char *)v9 + 0x2C) = v21;
    if ( v18 )
    {
        *((_DWORD *)v9 + 6) = *(_DWORD *)((char *)orig_func_addr + 0xFFFFFFFB);
        *((_WORD *)v9 + 0xE) = *(_WORD *)((char *)orig_func_addr + 0xFFFFFFFF);
        *((_BYTE *)v9 + 0x1E) = *((_BYTE *)orig_func_addr + 1);
    }
    else
    {
        *((_DWORD *)v9 + 6) = *(_DWORD *)orig_func_addr;
        *((_BYTE *)v9 + 0x1C) = *((_BYTE *)orig_func_addr + 4);
    }
    handler_list_last_node = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v10;
done:
    _InterlockedExchange(&g_lock_1, 0);
    return v2;
}
// 405BB0: using guessed type __int64 (__fastcall *handler_list_last_node)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 405BB8: using guessed type int g_lock_1;
// 405BEC: using guessed type int zz_g_buf_38h_used_cnt;

//----- (0000000000401C70) ----------------------------------------------------
signed __int64 __fastcall zzCheckInjectSpaceAvail(_BYTE *p, unsigned int len)
{
    char ch1; // r8
    _BYTE *p1; // r9
    unsigned int idx; // ecx

    ch1 = *p;
    p1 = p;
    if ( *p && ch1 != 0x90u && ch1 != 0xCCu )
        return 0i64;
    idx = 1;
    if ( len > 1 )
    {
        while ( p1[idx] == ch1 )
        {
            if ( ++idx >= len )
                return 1i64;
        }
        return 0i64;
    }
    return 1i64;
}

//----- (0000000000401CAC) ----------------------------------------------------
signed __int64 __fastcall CreateTrampolineFunction(void *orig_func_addr)
{
    unsigned __int8 v1; // r15
    unsigned __int8 v2; // r12
    unsigned __int64 v3; // r13
    unsigned __int64 *p_func_addr; // rbx
    __int64 v5; // rdi
    unsigned __int64 v6; // r12
    unsigned __int8 *oldInstr; // r14
    unsigned __int64 v8; // r8
    unsigned __int8 v9; // r9
    __int64 *v10; // rsi
    _BOOL8 v11; // rdx
    bool v12; // zf
    unsigned __int64 v13; // rdi
    _BYTE *v14; // r11
    unsigned __int64 v15; // rdx
    char ch2; // al
    _BYTE *v17; // rax
    unsigned int v18; // ecx
    signed __int64 result; // rax
    int v20; // ecx
    __int64 v21; // xmm0_8
    unsigned __int64 v22; // rdx
    __int64 v23; // rax
    unsigned __int64 v24; // rcx
    __int64 v25; // rax
    unsigned __int64 v26; // rdi
    char v27; // cl
    unsigned __int8 v28; // [rsp+20h] [rbp-49h]
    BOOL v29; // [rsp+24h] [rbp-45h]
    __int64 v30; // [rsp+28h] [rbp-41h]
    unsigned __int8 hs; // [rsp+30h] [rbp-39h]
    char v32; // [rsp+3Bh] [rbp-2Eh]
    char v33; // [rsp+3Ch] [rbp-2Dh]
    char v34; // [rsp+3Dh] [rbp-2Ch]
    char v35; // [rsp+3Fh] [rbp-2Ah]
    int v36; // [rsp+45h] [rbp-24h]
    int v37; // [rsp+4Dh] [rbp-1Ch]
    unsigned int v38; // [rsp+51h] [rbp-18h]
    __int64 v39; // [rsp+58h] [rbp-11h]
    int v40; // [rsp+60h] [rbp-9h]
    __int16 v41; // [rsp+64h] [rbp-5h]
    __int64 v42; // [rsp+68h] [rbp-1h]
    unsigned __int8 *v43; // [rsp+70h] [rbp+7h]
    __int16 v44; // [rsp+78h] [rbp+Fh]
    int v45; // [rsp+7Ah] [rbp+11h]
    __int16 v46; // [rsp+7Eh] [rbp+15h]
    unsigned __int8 *v47; // [rsp+80h] [rbp+17h]
    char v48; // [rsp+88h] [rbp+1Fh]

    v44 = 0x15FF;
    v47 = 0i64;
    v1 = 0;
    *(_DWORD *)((char *)&v39 + 2) = 0;
    v2 = 0;
    *(__int64 *)((char *)&v39 + 6) = 0i64;
    v3 = 0i64;
    v43 = 0i64;
    p_func_addr = (unsigned __int64 *)orig_func_addr;
    v28 = 0;
    v29 = 0;
    *((_QWORD *)orig_func_addr + 4) = 0i64;
    v45 = 2;
    v46 = 0x8EB;
    LOWORD(v39) = 0x25FF;
    v42 = 0x25FF0E70i64;
    while ( 1 )
    {
        v5 = v2;
        v6 = v2 + p_func_addr[2];
        oldInstr = (unsigned __int8 *)(*p_func_addr + v1);
        v30 = v5;
        v8 = (unsigned int)hde64_disasm(oldInstr, &hs);
        if ( v38 & 0x1000 )
            return 0i64;
        v9 = hs;
        v10 = (__int64 *)oldInstr;
        if ( v1 >= 5u )
        {
            *(__int64 *)((char *)&v39 + 6) = (__int64)oldInstr;
            v10 = &v39;
            LODWORD(v11) = 1;
            LODWORD(v8) = 0xE;
            goto LABEL_44;
        }
        if ( (v34 & 0xC7) == 5 )
        {
            qmemcpy(&v48, oldInstr, v8);
            v10 = (__int64 *)&v48;
            v12 = v32 == 0xFFu;
            *(_DWORD *)((char *)&v47 + v9 - (unsigned __int64)((v38 >> 2) & 0xF) + 4) = v37 + (_DWORD)oldInstr - v6;
            if ( v12 && v35 == 4 )
            {
                LODWORD(v11) = 1;
                goto LABEL_44;
            }
        }
        else if ( v32 == 0xE8u )
        {
            v10 = (__int64 *)&v44;
            LODWORD(v8) = 0x10;
            v47 = &oldInstr[v36 + hs];
        }
        else if ( (v32 & 0xFD) == 0xE9u )
        {
            v23 = (char)v36;
            if ( v32 != 0xEBu )
                v23 = v36;
            v24 = (unsigned __int64)&oldInstr[hs + v23];
            if ( *p_func_addr > v24 || v24 >= *p_func_addr + 5 )
            {
                *(__int64 *)((char *)&v39 + 6) = (__int64)&oldInstr[hs + v23];
                v10 = &v39;
                LODWORD(v8) = 0xE;
LABEL_43:
                v11 = (unsigned __int64)oldInstr >= v3;
LABEL_44:
                v29 = v11;
                goto LABEL_12;
            }
            if ( v3 >= v24 )
                v24 = v3;
            v3 = v24;
        }
        else if ( (v32 & 0xF0) == 0x70 || (v32 & 0xFC) == 0xE0u || (v33 & 0xF0) == 0x80u )
        {
            if ( (v32 & 0xF0) == 0x70 || (v25 = v36, (v32 & 0xFC) == 0xE0u) )
                v25 = (char)v36;
            v26 = (unsigned __int64)&oldInstr[hs + v25];
            if ( *p_func_addr > v26 || v26 >= *p_func_addr + 5 )
            {
                if ( (v32 & 0xFC) == 0xE0u )
                    return 0i64;
                v27 = v33;
                v10 = &v42;
                v43 = &oldInstr[hs + v25];
                LODWORD(v8) = 0x10;
                if ( v32 != 0xF )
                    v27 = v32;
                LOBYTE(v42) = v27 & 0xF ^ 0x71;
            }
            else
            {
                if ( v3 >= v26 )
                    v26 = v3;
                v3 = v26;
            }
            v5 = v30;
        }
        else if ( (v32 & 0xFE) == 0xC2u )
        {
            goto LABEL_43;
        }
        LODWORD(v11) = v29;
LABEL_12:
        if ( (unsigned __int64)oldInstr < v3 && (_DWORD)v8 != v9
          || (unsigned int)v8 + v28 > 0x32
          || *((_DWORD *)p_func_addr + 9) >= 8u )
        {
            return 0i64;
        }
        *((_BYTE *)p_func_addr + *((unsigned int *)p_func_addr + 9) + 0x28) = v1;
        v1 += v9;
        *((_BYTE *)p_func_addr + *((unsigned int *)p_func_addr + 9) + 0x30) = v28;
        v2 = v8 + v28;
        ++*((_DWORD *)p_func_addr + 9);
        v28 += v8;
        qmemcpy((void *)(p_func_addr[2] + v5), v10, (unsigned int)v8);
        if ( (_DWORD)v11 )
        {
            if ( v1 >= 5u
              || (v13 = *p_func_addr,
                  (unsigned int)zzCheckInjectSpaceAvail((_BYTE *)(*p_func_addr + v1), 5 - (unsigned int)v1)) )
            {
LABEL_29:
                result = 1i64;
                *(__int64 *)((char *)&v39 + 6) = p_func_addr[1];
                v20 = v40;
                v21 = v39;
                v22 = p_func_addr[2] + v2;
                p_func_addr[3] = v22;
                *(_QWORD *)v22 = v21;
                *(_DWORD *)(v22 + 8) = v20;
                *(_WORD *)(v22 + 0xC) = v41;
                return result;
            }
            if ( v1 >= 2u || (unsigned int)zzCheckInjectSpaceAvail(v14, 2 - (unsigned int)v1) )
            {
                if ( zzIsAddrPermOk((void *)(v13 - 5)) )
                {
                    v15 = *p_func_addr;
                    ch2 = *(_BYTE *)(*p_func_addr - 5);
                    if ( !ch2 || ch2 == 0x90u || ch2 == 0xCCu )
                    {
                        v17 = (_BYTE *)(v15 - 4);
                        v18 = 1;
                        while ( *v17 == *(_BYTE *)(v15 - 5) )
                        {
                            ++v18;
                            ++v17;
                            if ( v18 >= 5 )
                            {
                                *((_DWORD *)p_func_addr + 8) = 1;
                                goto LABEL_29;
                            }
                        }
                    }
                }
            }
            return 0i64;
        }
    }
}

//----- (0000000000402044) ----------------------------------------------------
_QWORD *__fastcall zzAllocFuncPage(unsigned __int64 a1)
{
    unsigned __int64 v1; // rdi
    _QWORD *v2; // r14
    char *v3; // r15
    _QWORD *v4; // rbx
    unsigned __int64 v5; // r15
    unsigned __int64 v6; // rsi
    _BYTE *v7; // r12
    _BYTE *v8; // rsi
    bool i; // zf
    DWORD v10; // er14
    unsigned __int64 v11; // rsi
    _QWORD *v12; // rcx
    unsigned __int64 v13; // rdx
    struct _SYSTEM_INFO SystemInfo; // [rsp+20h] [rbp-60h]
    struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp+50h] [rbp-30h]

    v1 = a1;
    GetSystemInfo(&SystemInfo);
    v2 = SystemInfo.lpMinimumApplicationAddress;
    v3 = (char *)SystemInfo.lpMaximumApplicationAddress;
    if ( v1 > 0x40000000 && SystemInfo.lpMinimumApplicationAddress < (LPVOID)(v1 - 0x40000000) )
        v2 = (_QWORD *)(v1 - 0x40000000);
    v4 = lpAddress;
    if ( SystemInfo.lpMaximumApplicationAddress > (LPVOID)(v1 + 0x40000000) )
        v3 = (char *)(v1 + 0x40000000);
    v5 = (unsigned __int64)(v3 + 0xFFFFF001);
    while ( v4 )
    {
        if ( v4 >= v2 && (unsigned __int64)v4 < v5 && v4[1] )
            return v4;
        v4 = (_QWORD *)*v4;
    }
    v6 = v1;
    while ( v6 >= (unsigned __int64)v2 )
    {
        v7 = (_BYTE *)SystemInfo.dwAllocationGranularity;
        v8 = (_BYTE *)(v6 - v6 % SystemInfo.dwAllocationGranularity);
        do
        {
            v6 = v8 - v7;
            if ( v6 < (unsigned __int64)v2 || !VirtualQuery((LPCVOID)v6, &Buffer, 0x30ui64) )
                break;
            if ( Buffer.State == 0x10000 )
                goto mem_free;
            v8 = Buffer.AllocationBase;
        }
        while ( Buffer.AllocationBase >= v7 );
        v6 = 0i64;
mem_free:
        if ( !v6 )
            break;
        v4 = VirtualAlloc((LPVOID)v6, 0x1000ui64, 0x3000u, 0x40u);
        if ( v4 )
            goto ptr_nz;
    }
    for ( i = 1; i; i = v4 == 0i64 )
    {
        if ( v1 > v5 )
            return v4;
        v10 = SystemInfo.dwAllocationGranularity;
        v11 = SystemInfo.dwAllocationGranularity;
        for ( v1 += SystemInfo.dwAllocationGranularity - v1 % SystemInfo.dwAllocationGranularity;
              v1 <= v5;
              v1 = (unsigned __int64)Buffer.BaseAddress
                 + Buffer.RegionSize
                 + v10
                 - ((unsigned __int64)Buffer.BaseAddress + Buffer.RegionSize + v10 - 1) % v11
                 - 1 )
        {
            if ( !VirtualQuery((LPCVOID)v1, &Buffer, 0x30ui64) )
                break;
            if ( Buffer.State == 0x10000 )
                goto LABEL_28;
        }
        v1 = 0i64;
LABEL_28:
        if ( !v1 )
            return v4;
        v4 = VirtualAlloc((LPVOID)v1, 0x1000ui64, 0x3000u, 0x40u);
    }
ptr_nz:
    v4[1] = 0i64;
    v12 = v4 + 8;
    *((_DWORD *)v4 + 4) = 0;
    v13 = 0x40i64;
    do
    {
        v13 += 0x40i64;
        *v12 = v4[1];
        v4[1] = v12;
        v12 += 8;
    }
    while ( v13 <= 0xFC0 );
    *v4 = lpAddress;
    lpAddress = v4;
    return v4;
}

//----- (0000000000402248) ----------------------------------------------------
int __fastcall zzPageNeedFree(unsigned __int64 *a1)
{
    unsigned __int64 *v1; // r8
    _QWORD *v2; // rdx
    _QWORD *v3; // rcx
    unsigned __int64 v4; // rax
    bool v5; // zf

    v1 = a1;
    v2 = 0i64;
    v3 = lpAddress;
    v4 = (unsigned __int64)v1 & 0xFFFFFFFFFFFFF000ui64;
    while ( v3 )
    {
        if ( v3 == (_QWORD *)v4 )
        {
            v4 = v3[1];
            *v1 = v4;
            v5 = (*((_DWORD *)v3 + 4))-- == 1;
            v3[1] = v1;
            if ( v5 )
            {
                if ( v2 )
                    *v2 = *v3;
                else
                    lpAddress = (LPVOID)*v3;
                LODWORD(v4) = VirtualFree(v3, 0i64, 0x8000u);
            }
            return v4;
        }
        v2 = v3;
        v3 = (_QWORD *)*v3;
    }
    return v4;
}

//----- (00000000004022B0) ----------------------------------------------------
BOOL __fastcall zzIsAddrPermOk(void *a1)
{
    struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp+20h] [rbp-38h]

    VirtualQuery(a1, &Buffer, 0x30ui64);
    return Buffer.State == 0x1000 && Buffer.Protect & 0xF0;
}

//----- (00000000004022E4) ----------------------------------------------------
__int64 __fastcall hde64_disasm(unsigned __int8 *code, unsigned __int8 *hs)
{
    char v2; // r11
    _BYTE *v3; // rsi
    char v4; // r15
    unsigned __int8 *v5; // r9
    unsigned __int8 *v6; // r8
    unsigned __int8 v7; // r10
    unsigned __int8 v8; // bp
    char v9; // r13
    char v10; // dl
    unsigned int v11; // edi
    char v12; // al
    char v13; // cl
    int v14; // edx
    unsigned __int8 v15; // r14
    unsigned __int8 v16; // bl
    __int16 v17; // r10
    unsigned __int16 v18; // r10
    unsigned __int8 v19; // si
    unsigned __int8 v20; // di
    unsigned __int8 *v21; // r9
    int v22; // edx
    unsigned __int8 v23; // r15
    unsigned __int8 v24; // r12
    unsigned __int8 v25; // di
    char v26; // r15
    unsigned __int8 v27; // al
    unsigned __int8 v28; // cl
    char v29; // al
    char v30; // dl
    _BYTE *v31; // rcx
    _BYTE *v32; // r10
    _BYTE *v33; // rcx
    _BYTE *v34; // rdx
    bool v35; // zf
    unsigned __int8 v36; // dl
    signed __int64 v37; // r9
    unsigned __int8 *v38; // r9
    __int16 v39; // ax
    __int64 v40; // rax
    __int16 v41; // ax
    unsigned __int8 v42; // al
    unsigned __int8 v43; // al
    unsigned __int8 v44; // r9
    int v46; // eax
    int v47; // eax
    unsigned __int8 *v48; // [rsp+30h] [rbp+8h]

    v48 = code;
    v2 = 0;
    v3 = &unk_405010;
    v4 = (char)code;
    v5 = code;
    v6 = hs;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    memset(hs, 0, 0x25ui64);
    v10 = 0x10;
    do
    {
        v11 = *v5++;
        if ( v11 > 0x66 )
        {
            switch ( v11 )
            {
                case 0x67u:
                    v6[5] = 0x67;
                    v12 = 0x10;
                    break;
                case 0xF0u:
                    v6[2] = 0xF0u;
                    v12 = 0x20;
                    break;
                case 0xF2u:
                    v6[1] = 0xF2u;
                    v12 = 2;
                    break;
                case 0xF3u:
                    v6[1] = v11;
                    v12 = 4;
                    break;
                default:
                    goto LABEL_17;
            }
            goto LABEL_16;
        }
        if ( v11 == 0x66 )
        {
            v6[4] = 0x66;
            v12 = 8;
            goto LABEL_16;
        }
        if ( (v11 - 0x26) & 0xFFFFFFE7 && v11 - 0x64 > 1 )
            break;
        v6[3] = v11;
        v12 = 0x40;
LABEL_16:
        v7 |= v12;
        --v10;
    }
    while ( v10 );
LABEL_17:
    v13 = 1;
    v14 = v7 << 0x17;
    *(_DWORD *)(v6 + 0x21) = v14;
    if ( v7 )
        v13 = v7;
    if ( (v11 & 0xF0) != 0x40 )
        goto LABEL_147;
    *(_DWORD *)(v6 + 0x21) = (v7 << 0x17) | 0x40000000;
    v6[7] = ((unsigned __int8)v11 >> 3) & 1;
    if ( ((unsigned __int8)v11 >> 3) & 1 )
    {
        v9 = 0;
        if ( (*v5 & 0xF8) == 0xB8u )
            v9 = 1;
    }
    v6[8] = ((unsigned __int8)v11 >> 2) & 1;
    v6[0xA] = v11 & 1;
    v6[9] = ((unsigned __int8)v11 >> 1) & 1;
    LOBYTE(v11) = *v5++;
    if ( (v11 & 0xF0) != 0x40 )
    {
LABEL_147:
        v6[0xB] = v11;
        v16 = v13;
        if ( (_BYTE)v11 == 0xF )
        {
            LOBYTE(v11) = *v5;
            v3 = &unk_40505A;
            v6[0xC] = *v5++;
        }
        else if ( (unsigned __int8)v11 >= 0xA0u )
        {
            v16 = v13;
            if ( (unsigned __int8)v11 <= 0xA3u )
            {
                ++v9;
                if ( v13 & 0x10 )
                    v16 = v13 | 8;
                else
                    v16 = v13 & 0xF7;
            }
        }
        v15 = v11;
        v2 = v3[(unsigned __int8)v3[(unsigned __int64)(unsigned __int8)v11 >> 2] + (v11 & 3)];
        if ( v2 == 0xFFu )
        {
            v2 = 0;
            goto LABEL_34;
        }
    }
    else
    {
        v15 = v11;
        v16 = v13;
LABEL_34:
        *(_DWORD *)(v6 + 0x21) |= 0x3000u;
        if ( (v11 & 0xFD) == 0x24 )
            v2 = 1;
    }
    LOBYTE(v17) = 0;
    if ( v2 < 0 )
    {
        v18 = *(_WORD *)&v3[v2 & 0x7F];
        v2 = *(_WORD *)&v3[v2 & 0x7F];
        v17 = v18 >> 8;
    }
    v19 = v6[0xC];
    if ( v19
      && v16 & *((_BYTE *)&unk_405010
               + (v11 & 3)
               + (unsigned __int64)*((unsigned __int8 *)&unk_405010
                                   + ((unsigned __int64)(unsigned __int8)v11 >> 2)
                                   + 0x13C)
               + 0x13C) )
    {
        *(_DWORD *)(v6 + 0x21) |= 0x3000u;
    }
    if ( !(v2 & 1) )
    {
        if ( v16 & 0x20 )
            *(_DWORD *)(v6 + 0x21) |= 0x9000u;
        goto LABEL_126;
    }
    *(_DWORD *)(v6 + 0x21) |= 1u;
    v20 = *v5;
    v21 = v5 + 1;
    v22 = *(_DWORD *)(v6 + 0x21);
    v23 = v20;
    v6[0xD] = v20;
    v24 = v20 & 7;
    v25 = (v20 >> 3) & 7;
    v26 = v23 >> 6;
    v6[0xE] = v26;
    v6[0x10] = v24;
    v6[0xF] = v25;
    if ( (_BYTE)v17 && (((unsigned __int8)v17 << v25) & 0x80u) != 0 )
        *(_DWORD *)(v6 + 0x21) = v22 | 0x3000;
    if ( !v19 && (unsigned __int8)(v15 + 0x27) <= 6u )
    {
        v27 = v15 + 0x27;
        if ( v26 == 3 )
        {
            v28 = v24;
            v29 = *((_BYTE *)&unk_405010 + 8 * v27 + v25 + 0x104);
        }
        else
        {
            v28 = v25;
            v29 = *((_BYTE *)&unk_405010 + v27 + 0xFD);
        }
        if ( ((v29 << v28) & 0x80u) != 0 )
            *(_DWORD *)(v6 + 0x21) |= 0x3000u;
    }
    if ( v16 & 0x20 )
    {
        if ( v26 == 3 )
            goto LABEL_61;
        v30 = v15;
        if ( v19 )
        {
            v31 = &unk_4051D6;
            v32 = &unk_4051E8;
        }
        else
        {
            v31 = &unk_4051BE;
            v30 = v15 & 0xFE;
            v32 = &unk_4051D6;
        }
        while ( *v31 != v30 )
        {
            v31 += 2;
            if ( v31 == v32 )
                goto LABEL_61;
        }
        if ( (((unsigned __int8)v31[1] << v25) & 0x80u) != 0 )
LABEL_61:
            *(_DWORD *)(v6 + 0x21) |= 0x9000u;
    }
    if ( !v19 )
    {
        if ( v15 != 0x8C )
        {
            if ( v15 != 0x8E )
                goto LABEL_74;
            if ( v25 == 1 )
                goto LABEL_96;
        }
        if ( v25 > 5u )
            goto LABEL_96;
        goto LABEL_97;
    }
    switch ( v15 )
    {
        case 0x20u:
            goto LABEL_148;
        case 0x21u:
            goto LABEL_67;
        case 0x22u:
LABEL_148:
            v26 = 3;
            if ( v25 <= 4u && v25 != 1 )
                goto LABEL_97;
            goto LABEL_96;
    }
    if ( v15 != 0x23 )
    {
LABEL_74:
        if ( v26 == 3 )
        {
            if ( v19 )
            {
                v33 = &unk_4051F7;
                v34 = &unk_405221;
            }
            else
            {
                v33 = &unk_4051E8;
                v34 = &unk_4051F7;
            }
            while ( *v33 != v15 )
            {
                v33 += 3;
                if ( v33 == v34 )
                    goto LABEL_97;
            }
            if ( !(v16 & v33[1]) || (((unsigned __int8)v33[2] << v25) & 0x80u) != 0 )
                goto LABEL_97;
LABEL_96:
            *(_DWORD *)(v6 + 0x21) |= 0x11000u;
            goto LABEL_97;
        }
        if ( !v19 )
            goto LABEL_97;
        if ( v15 != 0x50 )
        {
            if ( v15 == 0xC5 )
                goto LABEL_96;
            if ( v15 == 0xD6 )
            {
                v35 = (v16 & 6) == 0;
LABEL_91:
                if ( !v35 )
                    goto LABEL_96;
                goto LABEL_97;
            }
            if ( v15 != 0xD7 && v15 != 0xF7 )
                goto LABEL_97;
        }
        v35 = (v16 & 9) == 0;
        goto LABEL_91;
    }
LABEL_67:
    v26 = 3;
    if ( (unsigned __int8)(v25 - 4) <= 1u )
        goto LABEL_96;
LABEL_97:
    v36 = *v21;
    v37 = (signed __int64)(v21 + 1);
    if ( v25 <= 1u )
    {
        if ( v15 == 0xF6u )
        {
            v2 |= 2u;
        }
        else if ( v15 == 0xF7u )
        {
            v2 |= 0x10u;
        }
    }
    if ( v26 )
    {
        if ( v26 == 1 )
        {
            v8 = 1;
        }
        else if ( v26 == 2 )
        {
            v8 = 2;
            if ( !(v16 & 0x10) )
                v8 = 4;
        }
    }
    else if ( v16 & 0x10 )
    {
        v8 = v24 != 6 ? 0 : 2;
    }
    else
    {
        v8 = 0;
        if ( v24 == 5 )
            v8 = 4;
    }
    if ( v26 != 3 && v24 == 4 )
    {
        *(_DWORD *)(v6 + 0x21) |= 2u;
        ++v37;
        v6[0x12] = v36 >> 6;
        v6[0x11] = v36;
        v6[0x13] = (v36 >> 3) & 7;
        v6[0x14] = v36 & 7;
        if ( (v36 & 7) == 5 && !(v26 & 1) )
            v8 = 4;
    }
    v38 = (unsigned __int8 *)(v37 - 1);
    switch ( v8 )
    {
        case 1u:
            *(_DWORD *)(v6 + 0x21) |= 0x40u;
            v6[0x1D] = *v38;
            break;
        case 2u:
            *(_DWORD *)(v6 + 0x21) |= 0x80u;
            *(_WORD *)(v6 + 0x1D) = *(_WORD *)v38;
            break;
        case 4u:
            *(_DWORD *)(v6 + 0x21) |= 0x100u;
            *(_DWORD *)(v6 + 0x1D) = *(_DWORD *)v38;
            break;
    }
    v4 = (char)v48;
    v5 = &v38[v8];
LABEL_126:
    if ( v2 & 0x10 )
    {
        if ( v2 & 0x40 )
        {
            if ( v16 & 8 )
            {
                *(_DWORD *)(v6 + 0x21) |= 0x208u;
                v39 = *(_WORD *)v5;
                LOBYTE(v5) = (_BYTE)v5 + 2;
                *(_WORD *)(v6 + 0x15) = v39;
                goto LABEL_139;
            }
LABEL_144:
            *(_DWORD *)(v6 + 0x21) |= 0x210u;
            v47 = *(_DWORD *)v5;
            LOBYTE(v5) = (_BYTE)v5 + 4;
            *(_DWORD *)(v6 + 0x15) = v47;
            goto LABEL_139;
        }
        if ( v9 )
        {
            *(_DWORD *)(v6 + 0x21) |= 0x20u;
            v40 = *(_QWORD *)v5;
            v5 += 8;
            *(_QWORD *)(v6 + 0x15) = v40;
            goto LABEL_132;
        }
        if ( !(v16 & 8) )
        {
            *(_DWORD *)(v6 + 0x21) |= 0x10u;
            v46 = *(_DWORD *)v5;
            v5 += 4;
            *(_DWORD *)(v6 + 0x15) = v46;
            goto LABEL_132;
        }
LABEL_133:
        *(_DWORD *)(v6 + 0x21) |= 8u;
        v41 = *(_WORD *)v5;
        v5 += 2;
        *(_WORD *)(v6 + 0x15) = v41;
    }
    else
    {
LABEL_132:
        if ( v2 & 4 )
            goto LABEL_133;
    }
    if ( v2 & 2 )
    {
        *(_DWORD *)(v6 + 0x21) |= 4u;
        v42 = *v5++;
        v6[0x15] = v42;
    }
    if ( v2 & 0x40 )
        goto LABEL_144;
    if ( v2 & 0x20 )
    {
        *(_DWORD *)(v6 + 0x21) |= 0x204u;
        v43 = *v5;
        LOBYTE(v5) = (_BYTE)v5 + 1;
        v6[0x15] = v43;
    }
LABEL_139:
    v44 = (_BYTE)v5 - v4;
    *v6 = v44;
    if ( v44 > 0xFu )
    {
        *(_DWORD *)(v6 + 0x21) |= 0x5000u;
        *v6 = 0xF;
    }
    return *v6;
}

//----- (0000000000402D50) ----------------------------------------------------
void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
{
    signed __int64 v3; // rdx
    bool v4; // cf
    size_t v6; // r9
    unsigned __int64 v7; // rax
    size_t v8; // r9

    v3 = (_BYTE *)Src - (_BYTE *)Dst;
    if ( Size < 8 )
        goto LABEL_6;
    for ( ; (unsigned __int8)Dst & 7; --Size )
    {
        v4 = *(_BYTE *)Dst < *((_BYTE *)Dst + v3);
        if ( *(_BYTE *)Dst != *((_BYTE *)Dst + v3) )
            return (void *)(-v4 - ((unsigned int)v4 - 1));
        Dst = (char *)Dst + 1;
    }
    if ( !(Size >> 3) )
    {
LABEL_6:
        if ( !Size )
            return 0i64;
        while ( 1 )
        {
            v4 = *(_BYTE *)Dst < *((_BYTE *)Dst + v3);
            if ( *(_BYTE *)Dst != *((_BYTE *)Dst + v3) )
                break;
            Dst = (char *)Dst + 1;
            if ( !--Size )
                return 0i64;
        }
        return (void *)(-v4 - ((unsigned int)v4 - 1));
    }
    v6 = Size >> 5;
    if ( Size >> 5 )
    {
        while ( 1 )
        {
            v7 = *(_QWORD *)Dst;
            if ( *(_QWORD *)Dst != *(_QWORD *)((char *)Dst + v3) )
                break;
            v7 = *((_QWORD *)Dst + 1);
            if ( v7 != *(_QWORD *)((char *)Dst + v3 + 8) )
                goto LABEL_24;
            v7 = *((_QWORD *)Dst + 2);
            if ( v7 != *(_QWORD *)((char *)Dst + v3 + 0x10) )
                goto LABEL_23;
            v7 = *((_QWORD *)Dst + 3);
            if ( v7 != *(_QWORD *)((char *)Dst + v3 + 0x18) )
            {
                Dst = (char *)Dst + 8;
LABEL_23:
                Dst = (char *)Dst + 8;
LABEL_24:
                Dst = (char *)Dst + 8;
                break;
            }
            Dst = (char *)Dst + 0x20;
            if ( !--v6 )
            {
                Size &= 0x1Fu;
                goto LABEL_18;
            }
        }
    }
    else
    {
LABEL_18:
        v8 = Size >> 3;
        if ( !(Size >> 3) )
            goto LABEL_6;
        while ( 1 )
        {
            v7 = *(_QWORD *)Dst;
            if ( *(_QWORD *)Dst != *(_QWORD *)((char *)Dst + v3) )
                break;
            Dst = (char *)Dst + 8;
            if ( !--v8 )
            {
                Size &= 7u;
                goto LABEL_6;
            }
        }
    }
    v4 = _byteswap_uint64(v7) < _byteswap_uint64(*(_QWORD *)((char *)Dst + v3));
    return (void *)(-v4 - ((unsigned int)v4 - 1));
}

//----- (0000000000402E30) ----------------------------------------------------
void __fastcall zzRtlUnwindEx(void *a1, void *a2)
{
    __int64 ContextRecord; // [rsp+0h] [rbp-4D8h]

    RtlUnwindEx(a1, a2, 0i64, 0i64, (PCONTEXT)&ContextRecord, 0i64);
}

//----- (0000000000402E60) ----------------------------------------------------
void zzEmptyFunc()
{
    ;
}

//----- (0000000000402EA0) ----------------------------------------------------
signed __int64 __fastcall zzFindSectionForAddr(void *p_img, unsigned __int64 addr)
{
    unsigned int idx; // er9
    unsigned __int16 *pe; // r8
    unsigned __int64 addr_1; // r10
    void *sect_table; // rax
    unsigned __int64 virt_addr; // rdx

    idx = 0;
    pe = (unsigned __int16 *)((char *)p_img + *((signed int *)p_img + 0xF));// ptr to PE Header
    addr_1 = addr;
    sect_table = (char *)pe + pe[0xA] + 0x18;   // (SizeOfOptionalHeader = 0xF0) + (SizeOfCOFFHeader = 0x18)
    if ( !pe[3] )                               // num of sections
        return 0i64;
    while ( 1 )
    {
        virt_addr = *((unsigned int *)sect_table + 3);
        if ( addr_1 >= virt_addr && addr_1 < (unsigned int)(virt_addr + *((_DWORD *)sect_table + 2)) )
            break;
        ++idx;
        sect_table = (char *)sect_table + 0x28; // next section
        if ( idx >= pe[3] )
            return 0i64;
    }
    return (signed __int64)sect_table;
}

//----- (0000000000402EF0) ----------------------------------------------------
char __fastcall zzInSectionNeedRelocation(__int64 p_instr)
{
    __int64 p1; // rbx
    signed __int64 ret; // rax

    p1 = p_instr;
    LOBYTE(ret) = zzValidatePE64Image((void *)0x400000);// 4MB addr is MS-DOS header
    if ( (_DWORD)ret )
    {
        ret = zzFindSectionForAddr((void *)0x400000, p1 - 0x400000);
        if ( ret )
            LOBYTE(ret) = *(_DWORD *)(ret + 0x24) >= 0;// PointerToRelocations
    }
    return ret;
}

//----- (0000000000402F40) ----------------------------------------------------
bool __fastcall zzValidatePE64Image(void *p)
{
    bool result; // al
    char *p2; // rcx

    if ( *(_WORD *)p != 0x5A4D )                // "MZ" == 0x5A4D
        return 0;
    p2 = (char *)p + *((signed int *)p + 0xF);  // [0xF<<2 = 0x3C] = 0xE8
    result = 0;
    if ( *(_DWORD *)p2 == 0x4550 )              // "PE" == 0x4550
        result = *((_WORD *)p2 + 0xC) == 0x20B; // [0xE8+(0xC<<1) = 0x100] = 0x020B
                                                // IMAGE_NT_OPTIONAL_HDR64_MAGIC   0x20b   64 bit executable image
    return result;
}

// ALL OK, 25 function(s) have been successfully decompiled
